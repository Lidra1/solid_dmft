{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "50bbc308",
   "metadata": {},
   "source": [
    "# Plotting the spectral function"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e8d5feac",
   "metadata": {},
   "source": [
    "In this tutorial we go through the steps to plot tight-binding bands from a Wannier90 Hamiltonian and spectralfunctions with analytically continued (real-frequency) self-energies obtained from DMFT."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0d69c4d5",
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "from IPython.display import display\n",
    "from IPython.display import Image\n",
    "import numpy as np\n",
    "import importlib, sys\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import cm\n",
    "from timeit import default_timer as timer\n",
    "\n",
    "from ase.io.espresso import read_espresso_in\n",
    "\n",
    "from h5 import HDFArchive\n",
    "from solid_dmft.postprocessing import plot_correlated_bands as pcb"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c3ce4f44",
   "metadata": {},
   "source": [
    "## Configuration"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "42a860c4",
   "metadata": {},
   "source": [
    "The script makes use of the `triqs.lattice.utils` class, which allows to set up a tight-binding model based on a Wannier90 Hamiltonian. Additionally, you may upload a self-energy in the usual `solid_dmft` format to compute correlated spectral properties.\n",
    "Currently, the following options are implemented:\n",
    "<ol>\n",
    "<li>bandstructure</li>\n",
    "<li>Fermi slice</li>\n",
    "</ol>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b8d962f9",
   "metadata": {},
   "source": [
    "### Basic options"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b652e03a",
   "metadata": {},
   "source": [
    "We start with configuring these options. For this example we try a tight-binding bandstructure including the correlated bands (`kslice = False`, `'tb': True`, `'alatt': True`), but feel free to come back here to explore. Alternatively to an intensity plot of the correlated bands (`qp_bands`), you can compute the correlated quasiparticle bands assuming a Fermi liquid regime.\\\n",
    "The options for $\\Sigma(\\omega)$ are `calc` or `model`, which performs a Fermi liquid linearization in the low-frequency regime. The latter will be reworked, so better stick with `calc` for now."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b8f73a48",
   "metadata": {},
   "outputs": [],
   "source": [
    "kslice = False\n",
    "\n",
    "bands_config = {'tb': True, 'alatt': True, 'qp_bands': False, 'sigma': 'calc'}\n",
    "kslice_config = {'tb': True, 'alatt': True, 'qp_bands': False, 'sigma': 'calc'}\n",
    "config = kslice_config if kslice else bands_config"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c6ece97",
   "metadata": {},
   "source": [
    "### Wannier90"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d0ce79b",
   "metadata": {},
   "source": [
    "Next we will set up the Wannier90 Input. Provide the path, seedname, chemical potential and orbital order used in Wannier90. You may add a spin-component, and any other local Hamiltonian. For `t2g` models the orbital order can be changed (to `orbital_order_to`) and a local spin-orbit coupling term can be added (`add_lambda`). The spectral properties can be viewed projected on a specific orbital."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "27a94d47",
   "metadata": {},
   "outputs": [],
   "source": [
    "w90_path = './'\n",
    "w90_dict = {'w90_seed': 'svo', 'w90_path': w90_path, 'mu': 12.3958, 'n_orb': 3,\n",
    "            'orbital_order_w90': ['dxz', 'dyz', 'dxy'], 'add_spin': False, 'add_lambda': [0.0] * 3}\n",
    "\n",
    "orbital_order_to = ['dxy', 'dxz', 'dyz']\n",
    "proj_on_orb = None # or 'dxy' etc"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57f41c87",
   "metadata": {},
   "source": [
    "### BZ configuration"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f23d7e3a",
   "metadata": {},
   "source": [
    "#### Optional: ASE Brillouin Zone"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fc7b2fac",
   "metadata": {},
   "source": [
    "It might be helpful to have a brief look at the Brillouin Zone by loading an input file of your favorite DFT code (Quantum Espresso in this case). ASE will write out the special $k$-points, which we can use to configure the BZ path. Alternatively, you can of course define the dictionary `kpts_dict` yourself. Careful, it might not define $Z$, which is needed and added below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c6e46f88",
   "metadata": {},
   "outputs": [],
   "source": [
    "scf_in = './svo.scf.in'\n",
    "\n",
    "# read scf file\n",
    "atoms = read_espresso_in(scf_in)\n",
    "# set up cell and path\n",
    "lat = atoms.cell.get_bravais_lattice()\n",
    "path = atoms.cell.bandpath('', npoints=100)\n",
    "kpts_dict = path.todict()['special_points']\n",
    "\n",
    "for key, value in kpts_dict.items():\n",
    "    print(key, value)\n",
    "lat.plot_bz()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "31956a53",
   "metadata": {},
   "source": [
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e47c2a48",
   "metadata": {},
   "source": [
    "Depending on whether you select `kslice=True` or `False`, a corresponding `tb_config` needs to be provided containing information about the $k$-points, resolution (`n_k`) or `kz`-plane in the case of the Fermi slice. Here we just import the $k$-point dictionary provided by ASE above and add the $Z$-point. If you are unhappy with the resolution of the final plot, come back here and crank up `n_k`. For the kslice, the first letter corresponds to the upper left corner of the plotted Brillouin zone, followed by the lower left corner and the lower right one ($Y$, $\\Gamma$, and $X$ in this case)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "68c0f047",
   "metadata": {},
   "outputs": [],
   "source": [
    "# band specs\n",
    "tb_bands = {'bands_path': [('R', 'G'), ('G', 'X'), ('X', 'M'), ('M', 'G')], 'Z': np.array([0,0,0.5]), 'n_k': 50}\n",
    "tb_bands.update(kpts_dict)\n",
    "\n",
    "# kslice specs\n",
    "tb_kslice = {key: tb_bands[key] for key in list(tb_bands.keys()) if key.isupper()}\n",
    "kslice_update = {'bands_path': [('Y', 'G'),('G', 'X')], 'Y': np.array([0.5,0.0,0]), 'n_k': 50, 'kz': 0.0}\n",
    "tb_kslice.update(kslice_update)\n",
    "\n",
    "tb_config = tb_kslice if kslice else tb_bands"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bf58de16",
   "metadata": {},
   "source": [
    "### Self-energy"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "67e42361",
   "metadata": {},
   "source": [
    "Here we provide the info needed from the h5Archive, like the self-energy, iteration count, spin and block component and the frequency mesh used for the interpolation. The values for the mesh of course depend on the quantity of interest. For a kslice the resolution around $\\omega=0$ is crucial and we need only a small energy window, while for a bandstructure we are also interested in high energy features."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70fd0787",
   "metadata": {},
   "outputs": [],
   "source": [
    "freq_mesh_kslice = {'window': [-0.5, 0.5], 'n_w': int(1e6)}\n",
    "freq_mesh_bands = {'window': [-5, 5], 'n_w': int(1e3)}\n",
    "freq_mesh = freq_mesh_kslice if kslice else freq_mesh_bands\n",
    "\n",
    "dmft_path = './svo_example.h5'\n",
    "\n",
    "sigma_dict = {'dmft_path': dmft_path, 'it': 'last_iter', 'orbital_order_dmft': orbital_order_to, 'spin': 'up',\n",
    "              'block': 0, 'eta': 0.0, 'w_mesh': freq_mesh, 'linearize': False}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6e314f15",
   "metadata": {},
   "source": [
    "__Optional__: for completeness and as a sanity check we quickly take a look at the self-energy. Make sure you provide a physical one!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e7cb04b5",
   "metadata": {},
   "outputs": [],
   "source": [
    "with HDFArchive(dmft_path, 'r') as h5:\n",
    "    sigma_freq = h5['DMFT_results']['last_iter']['Sigma_freq_0']\n",
    "\n",
    "fig, ax = plt.subplots(1, 2, figsize=(10,2), squeeze=False, dpi=200)\n",
    "\n",
    "orb = 0\n",
    "sp = 'up_0'\n",
    "freq_mesh = np.array([w.value for w in sigma_freq[sp][orb,orb].mesh])\n",
    "\n",
    "ax[0,0].plot(freq_mesh, sigma_freq[sp][orb,orb].data.real)\n",
    "ax[0,1].plot(freq_mesh, -sigma_freq[sp][orb,orb].data.imag)\n",
    "\n",
    "ax[0,0].set_ylabel(r'Re$\\Sigma(\\omega)$')\n",
    "ax[0,1].set_ylabel(r'Im$\\Sigma(\\omega)$')\n",
    "for ct in range(2):\n",
    "    ax[0,ct].grid()\n",
    "    ax[0,ct].set_xlim(-2, 2)\n",
    "    ax[0,ct].set_xlabel(r'$\\omega$ (eV)')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8c249dc9",
   "metadata": {},
   "source": [
    "### Plotting options"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "93d1db24",
   "metadata": {},
   "source": [
    "Finally, you can choose colormaps for each of the functionalities from any of the available on <a href=\"https://matplotlib.org/stable/tutorials/colors/colormaps.html\">matplotlib colormaps</a>. `vmin` determines the scaling of the logarithmically scaled colorplots. The corresponding tight-binding bands will have the maximum value of the colormap. By the way, colormaps can be reversed by appending `_r` to the identifier."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a2d79e6d",
   "metadata": {},
   "outputs": [],
   "source": [
    "proj_on_orb = orbital_order_to.index(proj_on_orb) if proj_on_orb else None\n",
    "plot_config = {'colorscheme_bands': 'coolwarm', 'colorscheme_kslice': 'PuBuGn',\n",
    "               'colorscheme_qpbands': 'Greens', 'vmin': 0.1, 'proj_on_orb': proj_on_orb}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6b2e5a0e",
   "metadata": {},
   "source": [
    "## Run and Plotting"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89a67dd6",
   "metadata": {},
   "source": [
    "Now that everything is set up we may hit run. Caution, if you use a lot of $k$-points, this may take a while! In the current example, it should be done within a second."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7e875f21",
   "metadata": {},
   "outputs": [],
   "source": [
    "start_time = timer()\n",
    "\n",
    "tb_data, alatt_k_w, freq_dict, dft_mu = pcb.get_dmft_bands(fermi_slice=kslice, with_sigma=bands_config['sigma'],\n",
    "                                                           orbital_order_to=orbital_order_to, qp_bands=config['qp_bands'],\n",
    "                                                           **w90_dict, **tb_config, **sigma_dict)\n",
    "\n",
    "print('Run took {0:.3f} s'.format(timer() - start_time))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7780b5d",
   "metadata": {},
   "source": [
    "That's it. Now you can look at the output:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1936db33",
   "metadata": {},
   "outputs": [],
   "source": [
    "if kslice:\n",
    "    fig, ax = plt.subplots(1, figsize=(3,3), dpi=200)\n",
    "\n",
    "    pcb.plot_kslice(fig, ax, alatt_k_w, tb_data, freq_dict, w90_dict['n_orb'], tb_config,\n",
    "                    tb=config['tb'], alatt=config['alatt'], quarter=0, **plot_config)\n",
    "\n",
    "else:\n",
    "    fig, ax = plt.subplots(1, figsize=(6,3), dpi=200)\n",
    "\n",
    "    pcb.plot_bands(fig, ax, alatt_k_w, tb_data, freq_dict, w90_dict['n_orb'], dft_mu=0.,\n",
    "                   tb=config['tb'], alatt=config['alatt'], qp_bands=config['qp_bands'], **plot_config)\n",
    "\n",
    "    ax.set_ylim(-1.25,1.75)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "186cf322",
   "metadata": {},
   "source": [
    "---"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
